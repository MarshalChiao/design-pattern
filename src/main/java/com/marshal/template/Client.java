package com.marshal.template;

/**
 * @Author: Shaoshuai Jiao
 * @Date: Created on 2019/3/22
 * @Time: Created at 14:21
 * @Description:
 */

/**
 * 模板模式  行为型模式
 * 模板模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
 *      定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
 * 涉及两个角色：
 *      抽象模板（Abstract Template）角色：
 *          1.定义一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。
 *          2.定义并实现一个模板方法，这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。
 *              顶级逻辑逻辑也有可能调用一些具体方法。
 *      具体模板（Concrete Template）角色：
 *          1.实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。
 *          2.每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，
 *              从而使得顶级逻辑的实现各不相同。
 * 模板方法模式的结构
 *  模板方法模式有一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种：
 *      抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。
 *      模板方法：由抽象类声明并加以实现。一般来说，模板方法调用抽象方法来完成主要的逻辑功能，并且模板方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。
 *      钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模板方法的逻辑。
 * 优点：
 *      1.容易扩展。一般来说，抽象类中的模板方法是不易发生改变的部分，而抽象方法是容易发生变化的部分，
 *          因此通过增加实现类一般可以很容易实现功能的扩展，符合开闭原则。
 *      2.便于维护。对于模板方法模式来说，正是优于他们主要的逻辑相同，才使用了模板方法，
 *          假如不使用模板方法，任由这些相同代码散乱的分布在不同类中，维护起来非常不方便。
 *      3.比较灵活。因为有钩子方法，因此子类的实现也可以影响父类中主逻辑的运行。
 *          但是在灵活的同时，由于子类影响到了父类，违反了里氏替换原则，会给程序带来风险。这就对抽象类的设计有了更高的要求。
 * 适用场景：
 *      1.在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模板方法模式。
 *      2.在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。
 *      3.重要的、复杂的方法，可以考虑作为模板方法。
 * 关键代码：在抽象类实现，其他步骤在子类实现。
 * 总结：
 *      1.模板方法模式是一种类的行为型模式，在它的结构图中只有类之间的继承关系，没有对象关联关系。
 *      2.模板方法模式是基于继承的代码复用基本技术，模板方法模式的结构和用法也是面向对象设计的核心之一。
 *          在模板方法模式中可以将相同的代码放在父类中，而将不同的方法实现放在不同的子类中。
 *      3.策略模式和模板方法都是用于封装算法，前者是利用组合和委托模型，而后者则是继承。
 */
public class Client {

    public static void main(String[] args) {
        AbstractBusinessHandler saveMoneyHandler = new SaveMoneyHandler();
        saveMoneyHandler.execute();
    }
}
